---
layout: post
title: 为何我不喜欢使用存储过程
date: 2017-09-11
categories: tech
tags: [Tech, SQL]
description:
---
最近项目中有个新需求，需要校验一个用户是否有Job,Certification,Disclosure这三个业务数据。    
追查系统的用户个人页面的代码发现，C#代码调用了三个存储过程，去抓取用户的Job,Certification,Disclosure数据。    
我的新需求，自然需要复用这三个存储过程，否则:
> * 代码重复。  
> * 后期若读取业务逻辑变化，难以追查所有读取Job,Certification,Disclosure的SQL，难以维护。    

如果我在C#代码中调用已有的三个存储过程进行复用，事情本该非常快就能完成。我也是这么做的。      
但code reviewer认为，我的需求中，并不需要Job,Certification,Disclosure这三个业务对象的数据，我只是要知道给定用户是否有Job,Certification,Disclosure而已。所以我应该将是否有无Job,Certification,Disclosure的判断逻辑写在数据库，最终通过网络从数据库传到web服务器的仅是true或false，节省网络流量，这样最好不过了。   
这样也对。除开网络性能，从接口设计的角度讲，接口的传入和返回值，都应是你本身需要的数据，不应带有大量不需要或者需要caller去预处理的数据。这样代码可读性也会有大大提高。    
改。但没想到的是，问题来了。    
为了简化问题，假设现有的存储过程如下：
```
CREATE PROCEDURE [dbo].[GetJobs]
(
	@PersonId int,
	@OrganizaitionId int
 )
AS
BEGIN
  SELECT JobId,JobName,JobType FROM Job WHERE PersonId = @PersonId AND OrganizaitionId = @OrganizaitionId
END
```
我在我自己的存储过程中调用它，我想获得该person有多少个jobs，即`getJobs`返回结果集的count。    
为了实现这一目的，我首先想到的便是使用临时表，将返回结果集存下来再进行`count(*)`的计数操作：
```
CREATE PROCEDURE [dbo].[MyProc]
(
	@PersonId int,
	@OrganizaitionId int,
 )
AS
BEGIN
  CREATE TABLE #Temp(
    PersonId int,
    OrganizaitionId int
  )

  INSERT INTO #Temp EXEC dbo.GetJobs
    @PersonId = @PersonId,
    @ParentOrgId = @ParentOrgId

  SELECT COUNT(*) FROM #Temp
END
```
这种办法简单有效，但它有严重的维护问题。被调用的存储过程的返回结果集字段如果变动，`MyProc`中的临时表结构也得随之变化。这是令人难以接受的。   
那么将`MyProc`中的INSERT INTO换为SELECT INTO呢？很遗憾，答案是不行。SQL本身并不支持这种写法。   
给现有存储过程`GetJobs`加`output`参数？因为GetJobs已被其他多处代码或SQL scripts调用，所以对现有现有存储过程进行改动会有不小风险。
我搜遍网络，一位MS MVP的大神的文章几乎总结了所有存储过程之间传递数据的方法: [How to Share Data between Stored Procedures](http://www.sommarskog.se/share_data.html#tableparam)。他在文章中也无可奈何地说道
> Keep in mind that compared to languages such as C# and Java, Transact-SQL is poorly equipped for code reuse, why solutions in T‑SQL to reuse code are clumsier.   

最终我也没能找到一种满意的办法，我在我自己的存储过程中又将查询语句写一了次。    
存储过程在场景时有其优势，比如性能与单元测试。但在写业务逻辑的通用方法时，非常不推荐将其写在存储过程中，代码复用、扩展与客户端语言比，相差甚远。
